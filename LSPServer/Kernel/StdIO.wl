BeginPackage["LSPServer`StdIO`"]

initializeLSPComm
readEvalWriteLoop

Begin["`Private`"]

Needs["LSPServer`"]
Needs["LSPServer`Library`"]
Needs["LSPServer`Utils`"]
Needs["CodeParser`Utils`"]

(* ========================================================== *)
(* ================   StdIO functions   ===================== *)
(* ========================================================== *)



(* =================   Initialize   ======================= *)

initializeLSPComm["StdIO"] := (
  StartBackgroundReaderThread[];
  Null
)


(* =================   Read Message   ======================= *)

TryQueue["StdIO"] :=
  Catch[
  Module[{bytes,
    queueSize, frontMessageSize,
    content,
    bytessIn, contentsIn,
    backgroundReaderThreadError, errStr, ferror
    },

    backgroundReaderThreadError = GetBackgroundReaderThreadError[];

    If[backgroundReaderThreadError != 0,

      Switch[backgroundReaderThreadError,
        $LSPServerLibraryError["FREAD_FAILED"],
          Which[
            GetStdInFEOF[] != 0,
              errStr = "fread EOF"
            ,
            (ferror = GetStdInFError[]) != 0,
              errStr = "fread error: " <> ToString[ferror]
            ,
            True,
              errStr = "fread unknown error"
          ]
        ,
        $LSPServerLibraryError["UNEXPECTED_LINEFEED"],
          errStr = "unexpected linefeed"
        ,
        $LSPServerLibraryError["EXPECTED_LINEFEED"],
          errStr = "expected linefeed"
        ,
        $LSPServerLibraryError["UNRECOGNIZED_HEADER"],
          errStr = "unrecognized header"
        ,
        _,
          errStr = "UNKNOWN ERROR: " <> ToString[backgroundReaderThreadError]
      ];

      log["\n\n"];
      log["Background Reader Thread Error: ", errStr];
      log["\n\n"];

      If[TrueQ[$ServerState == "shutdown"],
        exitSemiGracefully[]
        ,
        exitHard[]
      ]
    ];

    LockQueue[];

    queueSize = GetQueueSize[];

    If[queueSize == 0,

      UnlockQueue[];

      Throw[Null]
    ];

    If[$Debug2,
        log["\n\n"];
        log["messages in queue: ", queueSize];
        log["\n\n"]
    ];

    bytessIn = {};
    Do[

      frontMessageSize = GetFrontMessageSize[];

      bytes = PopQueue[frontMessageSize];

      AppendTo[bytessIn, bytes]
      , 
      queueSize
    ];

    UnlockQueue[];

    contentsIn = {};
    Do[
      If[FailureQ[bytesIn],
        log["\n\n"];
        log["invalid bytes from stdin: ", bytesIn];
        log["\n\n"];
        
        exitHard[]
      ];

      If[$Debug2,
        log["C-->S " <> ToString[Length[bytesIn]] <> " bytes"];
        log["C-->S " <> stringLineTake[FromCharacterCode[Normal[Take[bytesIn, UpTo[1000]]]], UpTo[20]]];
        log["...\n"]
      ];

      content = ImportByteArray[bytesIn, "RawJSON"];

      AppendTo[contentsIn, content]
      ,
      {bytesIn, bytessIn}
    ];

    bytessIn = {};

    expandUpdate[contentsIn]
    
  ]];

(* ================   Write Message   ======================= *)
(* contents is a list of Associations *)
writeLSPResult["StdIO", sock_, contents_] := writeLSPResult["StdIO", contents];

writeLSPResult["StdIO", contents_] :=
Module[{bytess, res, errStr, ferror},

  Check[
    bytess = ExportByteArray[#, "JSON"]& /@ contents

    ,
    log["\n\n"];
    log["message generated by contents: ", contents];
    log["\n\n"]
    ,
    {Export::jsonstrictencoding}
  ];
  (*
  write out each byte array in bytess
  *)
  Do[

    If[!ByteArrayQ[bytes],

        log["\n\n"];
        log["invalid bytes: ", bytes];
        log["\n\n"];

        exitHard[]
    ];
    (*
    Write the headers
    *)
    Do[
      If[$Debug2,
          log[""];
          log["C<--S  ", line]
      ];

      res = WriteLineToStdOut[line];
      If[res =!= 0,

        Switch[res,
          $LSPServerLibraryError["FWRITE_FAILED"] | $LSPServerLibraryError["FFLUSH_FAILED"],
            Which[
              GetStdOutFEOF[] != 0,
                errStr = "fwrite EOF"
              ,
              (ferror = GetStdOutFError[]) != 0,
                errStr = "fwrite error: " <> ToString[ferror]
                ,
                True,
                  errStr = "fwrite unknown error"
            ]
          ,
          _,
            errStr = "UNKNOWN ERROR: " <> ToString[res]
        ];

        log["\n\n"];
        log["StdOut error: ", errStr];
        log["\n\n"];

        If[TrueQ[$ServerState == "shutdown"],
          exitSemiGracefully[]
          ,
          exitHard[]
          ]
      ]
      ,
      {line, {"Content-Length: " <> ToString[Length[bytes]], ""}}
    ];
    (*
    Write the body
    *)
    If[$Debug2,
      log["C<--S  ", stringLineTake[FromCharacterCode[Normal[Take[bytes, UpTo[1000]]]], UpTo[20]]];
      log["...\n"]
    ];

    res = WriteBytesToStdOut[bytes];
    If[res =!= 0,

      Switch[res,
        $LSPServerLibraryError["FWRITE_FAILED"] | $LSPServerLibraryError["FFLUSH_FAILED"],
          Which[
            GetStdOutFEOF[] != 0,
              errStr = "fwrite EOF"
            ,
            (ferror = GetStdOutFError[]) != 0,
              errStr = "fwrite error: " <> ToString[ferror]
            ,
            True,
              errStr = "fwrite unknown error"
          ]
        ,
        _,
          errStr = "UNKNOWN ERROR: " <> ToString[res]
      ];

      log["\n\n"];
      log["StdOut error: ", errStr];
      log["\n\n"];

      If[TrueQ[$ServerState == "shutdown"],
        exitSemiGracefully[]
        ,
        exitHard[]
      ]
    ]
    ,
    {bytes, bytess} 
  ](*Do bytess*)
]

readEvalWriteLoop["StdIO", sock_]:= 
Module[{content, contents},

  (*
  loop over:
    read content
    evaluate
    write content
  *)

  While[True,

    TryQueue["StdIO"];

    ProcessScheduledJobs[];

    If[empty[$ContentQueue],
      Pause[0.1];
      Continue[]
    ];

    content = $ContentQueue[[1]];
    $ContentQueue = Rest[$ContentQueue];

    If[$Debug2,
      log["taking first from $ContentQueue: ", #["method"]&[content]];
      log["rest of $ContentQueue (up to 20): ", Take[#["method"]& /@ $ContentQueue, UpTo[20]]];
      log["..."]
    ];

    contents = LSPEvaluate[content];

    (* write out evaluated results to the client *)
    writeLSPResult["StdIO", sock, contents];

  ](*While*)
];

End[]

EndPackage[]
