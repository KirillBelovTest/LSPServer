BeginPackage["LSPServer`Socket`"]



findMessageParts
lspMsgAssoc
writeLSPResult

Begin["`Private`"]

Needs["LSPServer`"]
Needs["LSPServer`Utils`"]
Needs["CodeParser`Utils`"]
Needs["LSPServer`Library`"]

(* ========================================================== *)
(* ================   Socket functions   ==================== *)
(* ========================================================== *)

lspMsgAssoc = <|"lspMsg" -> "", "msgInQue" -> ""|>;

(* =================   Initialize   ======================= *)

(* "tcp_mode": "host", "tcp_port": 5555 *)

initializeLSPComm["Socket"] := SocketConnect[5555, "TCP"]

(* ===============   Message validity check    =============== *)

checkContent[str_] := StringContainsQ[str, "Content-Length: "];

checkStartPosition[str_] := First @ Flatten @ StringPosition[str, "Content"] === 1;

checkMsgLength[str_] :=
  Module[{numStrs, pos, reqdLength, maxMsgLength},
    (* Position of the header *)
    numStrs = StringCases[str, "Content-Length: " ~~ length:NumberString :> length];
    reqdLength = ToExpression[First[numStrs]];
    (* Extract the header*)
    pos = StringPosition[str, "Content-Length: " <> # <> "\r\n\r\n"]& /@ numStrs // Flatten;
    maxMsgLength = StringLength @ StringTake[str, {pos[[2]] + 1, StringLength[str]}];

    maxMsgLength >= reqdLength
  ];

msgContainsQ[str_] :=
  Module[{res},
    If[checkContent[str],
      If[checkStartPosition[str] && checkMsgLength[str],
        res = True;
        ,
        res = False;
      ]
      ,
      res = False;
    ];
    res
  ]

findMessageParts[str_] :=
  Module[{numStrs, msgLength, headerPosition},
    If[checkContent[lspMsgAssoc["msgInQue"] <> str],
      If[checkStartPosition["" <> str] && checkMsgLength[str],
        numStrs = First @ StringCases[str, "Content-Length: " ~~ length:NumberString :> length];
        msgLength = ToExpression[numStrs];
        headerPosition = Flatten @ StringPosition[str, "Content-Length: " <> numStrs <> "\r\n\r\n"];

        lspMsgAssoc["lspMsg"]   = StringTake[str, {headerPosition[[2]] + 1, headerPosition[[2]] + msgLength}];
        lspMsgAssoc["msgInQue"] = StringTake[str, {headerPosition[[2]] + 1 + msgLength, StringLength[str]}];
        ,
        lspMsgAssoc["msgInQue"] = lspMsgAssoc["msgInQue"] <> str;
      ]
      ,
      lspMsgAssoc["msgInQue"] = lspMsgAssoc["msgInQue"] <> str;
    ];
    lspMsgAssoc
  ];




(* ===================     Read     ========================= *)

queueEmptyQ["Socket"] :=
  Module[{getMethods},
    getMethods = #["method"]& /@ $ContentQueue;
    MatchQ[getMethods, {}]
  ];

readMessage["Socket", sockObj_] :=
  Module[{sockMessage},
    (* First check if a valid msg is available in the que *)
    (* When a valid message is available in the queue: No need to read new message from socket *)
    If[msgContainsQ[lspMsgAssoc["msgInQue"]],
      If[$Debug2,
        log["Valid message is availble in the MessageQueue :> "];
        log["\nmsgInQue :> \n"];
        log[InputForm[lspMsgAssoc["msgInQue"]]];
      ];
      sockMessage = "";
      ,
      (* When no valid message is available in the queue: read from socket *)
      If[$Debug2,
        log["No valid message is availble in the MessageQueue :> "];
        log["\nmsgInQue :> \n"];
        log[InputForm[lspMsgAssoc["msgInQue"]]];
      ];
      Pause[0.05];
      sockMessage = SocketReadMessage[sockObj];
      If[FailureQ[sockMessage],
        sockMessage = ""
        ,
        sockMessage = ByteArrayToString[sockMessage]
      ];
    ];
    (* Extract a valid message from the queue and update  lspMsgAssoc *)
    sockMessage = findMessageParts[lspMsgAssoc["msgInQue"] <> sockMessage];
    {ImportString[lspMsgAssoc["lspMsg"], "RawJSON"]}
  ];

(* Read + Expand + Update *)

TryQueue["Socket", sockObj_] :=
  Catch[
    Module[{contentsIn},
      If[queueEmptyQ["Socket"],
        If[$Debug2,
          log["\n\n $ContentQueue is empty, No more messages to deliver, Go to Read messages Section.\n\n "];
        ]
        ,
        If[$Debug2,
          log["\n\n $ContentQueue is not empty, No Read messages.\n\n "];
        ];
        Throw[Null]
      ];
      contentsIn = readMessage["Socket", sockObj];
      expandUpdate[contentsIn];
      Null
    ]
  ]




(* ===================     Write     ======================== *)


writeSocket["Socket", socket_, header_, body_] :=
  Module[{},
    BinaryWrite[socket, StringToByteArray @ header];
    BinaryWrite[socket, body];
  ];

(* contents is a list of Associations *)
writeLSPResult["Socket", sockObject_, contents_] :=
  Module[{bytess, line, bytes},

    Check[
      bytess = ExportByteArray[#, "JSON"]& /@ contents

      ,
      log["\n\n"];
      log["message generated by contents: ", contents];
      log["\n\n"]
      ,
      {Export::jsonstrictencoding}
    ];


    (*
    write out each byte array in bytess
    *)
    Do[
      If[!ByteArrayQ[bytes],
        log["\n\n"];
        log["invalid bytes: ", bytes];
        log["\n\n"];
        exitHard[]
      ];
      line = "Content-Length: " <> ToString[Length[bytes]] <> "\r\n\r\n";
      writeSocket["Socket", sockObject, line, bytes];
      ,
      {bytes, bytess}
    ](*Do bytess*)
  ];


  (* ================= Read Write Loop =============================== *)
readEvalWriteLoop["Socket", sock_]:= 
Module[{content, contents},
  While[True,

    TryQueue["Socket", sock];

    ProcessScheduledJobs[];

    If[empty[$ContentQueue],
      Pause[0.1];
      Continue[]
    ];

    content = $ContentQueue[[1]];
    $ContentQueue = Rest[$ContentQueue];

    If[$Debug2,
      log["taking first from $ContentQueue: ", #["method"]&[content]];
      log["rest of $ContentQueue (up to 20): ", Take[#["method"]& /@ $ContentQueue, UpTo[20]]];
      log["..."]
    ];

    contents = LSPEvaluate[content];

    (* write out evaluated results to the client *)
    writeLSPResult["Socket", sock, contents];

  ](*While*)
];

End[]

EndPackage[]